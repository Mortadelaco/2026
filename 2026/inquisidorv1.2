import json
import os
from datetime import datetime, date

# --- CONFIGURACI√ìN ---
DB_FILE = "inquisidor_db.json"
VERSION = "1.2"


class Inquisidor:
    def __init__(self):
        self.data = self.load_data()

    # ------------------------------------------------------------------ #
    #  PERSISTENCIA                                                        #
    # ------------------------------------------------------------------ #

    def load_data(self):
        if not os.path.exists(DB_FILE):
            return []
        try:
            with open(DB_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, ValueError):
            print("‚ö†Ô∏è  El archivo de datos estaba corrupto. Se ha iniciado con una base de datos vac√≠a.")
            return []

    def save_data(self):
        """Guarda los datos con manejo de errores de I/O."""  # CORRECCI√ìN #6
        try:
            with open(DB_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=4, default=str)
        except OSError as e:
            print(f"‚ùå Error al guardar los datos: {e}")
            print("   Comprueba los permisos del directorio o el espacio en disco.")

    # ------------------------------------------------------------------ #
    #  HELPERS DE VALIDACI√ìN                                               #
    # ------------------------------------------------------------------ #

    @staticmethod
    def _pedir_float(mensaje, min_val, max_val):
        """Pide un float en [min_val, max_val] hasta que el usuario introduzca uno v√°lido."""  # CORRECCI√ìN #2
        while True:
            try:
                valor = float(input(mensaje))
                if min_val <= valor <= max_val:
                    return valor
                print(f"   Por favor, introduce un n√∫mero entre {min_val} y {max_val}.")
            except ValueError:
                print("   Error: introduce un n√∫mero v√°lido.")

    @staticmethod
    def _pedir_int_no_negativo(mensaje):
        """Pide un entero >= 0."""  # CORRECCI√ìN #2
        while True:
            try:
                valor = int(input(mensaje))
                if valor >= 0:
                    return valor
                print("   El valor no puede ser negativo.")
            except ValueError:
                print("   Error: introduce un n√∫mero entero v√°lido.")

    @staticmethod
    def _confirmar(mensaje):
        """Pregunta s/n y acepta variantes comunes de 's√≠'."""  # CORRECCI√ìN #8
        while True:
            resp = input(mensaje).strip().lower()
            if resp in ('s', 'si', 's√≠', 'yes', 'y'):
                return True
            if resp in ('n', 'no'):
                return False
            print("   Responde con 's' o 'n'.")

    # ------------------------------------------------------------------ #
    #  L√ìGICA PRINCIPAL                                                    #
    # ------------------------------------------------------------------ #

    def registrar_dia(self, fecha_str=None, es_backup=False):
        """Registra los datos del d√≠a. Si fecha_str es None, usa hoy."""
        if not fecha_str:
            fecha_str = str(date.today())
            print(f"\n--- REGISTRO DIARIO ({fecha_str}) ---")
        else:
            print(f"\n--- BACKUP MODE ({fecha_str}) ---")

        # Verificar si ya existe un registro para esa fecha
        for entry in self.data:
            if entry['fecha'] == fecha_str:
                print("‚ö†Ô∏è  Ya existe un registro para esta fecha.")
                if not self._confirmar("¬øSobreescribir? (s/n): "):  # CORRECCI√ìN #8
                    return
                self.data.remove(entry)
                break

        friccion  = self._pedir_float("1. Nivel de Fricci√≥n (0-3): ", 0, 3)          # CORRECCI√ìN #2
        prod_base = self._pedir_float("2. % Realismo Base percibido (0-100): ", 0, 100)  # CORRECCI√ìN #2

        print("\n3. Autoobservaci√≥n (M√≠nimo 15 min de percepci√≥n pura)")
        auto_observacion = self._confirmar("¬øHas reflexionado objetivamente hoy? (s/n): ")  # CORRECCI√ìN #8

        idealismos = self._pedir_int_no_negativo("4. ¬øCu√°ntos idealismos detectaste hoy?: ")  # CORRECCI√ìN #2

        nuevo_registro = {
            "fecha": fecha_str,
            "friccion": friccion,
            "realismo_base": prod_base,
            "auto_observacion": auto_observacion,
            "idealismos": idealismos,
            "es_backup": es_backup
        }

        self.data.append(nuevo_registro)
        self.data.sort(key=lambda x: x['fecha'])  # Mantener orden cronol√≥gico
        self.save_data()
        print("‚úÖ Datos guardados.")

    def registrar_backup(self):
        print("\n--- MODO BACKUP ---")
        fecha_input = input("Introduce la fecha a recuperar (YYYY-MM-DD): ").strip()
        try:
            fecha_dt = datetime.strptime(fecha_input, "%Y-%m-%d").date()
        except ValueError:
            print("‚ùå Formato de fecha incorrecto. Usa YYYY-MM-DD.")
            return

        # CORRECCI√ìN #5: no permitir fechas futuras
        if fecha_dt > date.today():
            print("‚ùå No puedes registrar datos para una fecha futura.")
            return

        self.registrar_dia(fecha_str=fecha_input, es_backup=True)

    def calcular_estadisticas(self):
        if not self.data:
            print("No hay datos registrados.")
            return

        mes_actual = str(date.today())[:7]  # YYYY-MM
        registros_mes = [r for r in self.data if r['fecha'].startswith(mes_actual)]

        if not registros_mes:
            print(f"No hay datos para {mes_actual}.")
            return

        total_dias = len(registros_mes)
        media_base = sum(r['realismo_base'] for r in registros_mes) / total_dias

        # Penalizaci√≥n por Idealismos
        total_idealismos   = sum(r.get('idealismos', 0) for r in registros_mes)
        penalizacion_idealismos = total_idealismos * 1.0

        # Factor Disciplina (Autoobservaci√≥n: objetivo 2 veces por semana)
        # CORRECCI√ìN #3: usar los d√≠as realmente registrados en el mes,
        # no el d√≠a-del-mes del sistema, para un c√°lculo m√°s justo.
        dias_registrados      = total_dias
        semanas_transcurridas = max(1, dias_registrados / 7)
        objetivo_ao           = semanas_transcurridas * 2
        total_ao              = sum(1 for r in registros_mes if r['auto_observacion'])

        factor_disciplina = 1.0
        msg_disciplina    = "CUMPLIDO"
        if total_ao < objetivo_ao:
            factor_disciplina = 0.75
            msg_disciplina    = f"FALLIDO ({total_ao}/{int(objetivo_ao)})"

        # F√≥rmula final
        realismo_final = (media_base * factor_disciplina) - penalizacion_idealismos

        # CORRECCI√ìN #4: avisar si el valor est√° fuera del rango l√≥gico
        aviso_rango = ""
        if realismo_final < 0:
            aviso_rango = "  ‚ö†Ô∏è  Valor por debajo de 0% (fuera del rango l√≥gico)"
        elif realismo_final > 100:
            aviso_rango = "  ‚ö†Ô∏è  Valor por encima de 100% (fuera del rango l√≥gico)"

        print(f"\n=== INFORME MENSUAL ({mes_actual}) ===")
        print(f"üìÖ D√≠as registrados:          {total_dias}")
        print(f"üß† Realismo Base Promedio:    {media_base:.2f}%")
        print(f"üëÅÔ∏è  Autoobservaci√≥n:           {msg_disciplina} -> Factor {factor_disciplina}")
        print(f"ü¶Ñ Idealismos Totales:         {total_idealismos} -> Penalizaci√≥n -{penalizacion_idealismos:.2f}%")
        print("-" * 40)
        print(f"üìä REALISMO TOTAL: {realismo_final:.2f}%{aviso_rango}")

    def idealismo_rapido(self):
        """Suma 1 idealismo al d√≠a de hoy sin pedir el resto de datos."""
        hoy = str(date.today())
        encontrado = False

        for r in self.data:
            if r['fecha'] == hoy:
                r['idealismos'] = r.get('idealismos', 0) + 1
                encontrado = True
                print(f"ü¶Ñ Idealismo a√±adido. Total hoy: {r['idealismos']}")
                break

        if not encontrado:
            print("‚ö†Ô∏è  No has iniciado el d√≠a. Creando registro b√°sico...")
            nuevo = {
                "fecha": hoy,
                "friccion": 0,
                "realismo_base": 100,
                "auto_observacion": False,
                "idealismos": 1,
                "es_backup": False
            }
            self.data.append(nuevo)
            self.data.sort(key=lambda x: x['fecha'])  # CORRECCI√ìN #1
            print("Registro creado con 1 idealismo. Recuerda rellenar el resto luego.")

        self.save_data()

    # ------------------------------------------------------------------ #
    #  MEN√ö                                                                #
    # ------------------------------------------------------------------ #

    def menu(self):
        opciones = {'1', '2', '3', '4', '5'}
        while True:
            print(f"\n--- INQUISIDOR v{VERSION} ---")
            print("1. Registrar Hoy")
            print("2. Registrar Idealismo R√°pido (Hoy)")
            print("3. Modo Backup (Registrar pasado)")
            print("4. Ver Estad√≠sticas Mensuales")
            print("5. Salir")
            op = input("Elige: ").strip()

            # CORRECCI√ìN #7: validar entradas del men√∫
            if op not in opciones:
                print("‚ùå Opci√≥n no v√°lida. Elige un n√∫mero del 1 al 5.")
                continue

            if   op == '1': self.registrar_dia()
            elif op == '2': self.idealismo_rapido()
            elif op == '3': self.registrar_backup()
            elif op == '4': self.calcular_estadisticas()
            elif op == '5':
                print("üëã Hasta luego.")
                break


# ------------------------------------------------------------------ #
#  PUNTO DE ENTRADA                                                    #
# ------------------------------------------------------------------ #

if __name__ == "__main__":
    app = Inquisidor()
    app.menu()
